import logging
import os
import json
import mido
import time
import wave
import keyboard
import simpleaudio as sa
import csv

tempo = '80' # Set as the value of one the available metronome tracks in the "metronome_tracks" folder
recording_name = 'recording'

try:

    # Define the log file path 
    log_filename = os.path.abspath(f'recording_logs/{recording_name}.log')
    os.makedirs(os.path.dirname(log_filename), exist_ok=True)

    # Create a custom logger
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.DEBUG)

    # Create file handler (logging to file only)
    file_handler = logging.FileHandler(log_filename)
    file_handler.setLevel(logging.DEBUG)

    # Create a logging format
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)

    # Add file handler to the logger
    logger.addHandler(file_handler)

    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.ERROR)  # Set to ERROR to limit console output
    logger.addHandler(console_handler)

    logger.info("Recording started.")
    
    # ---------------------------------------------------------------

    # Generate the filename based on the parameters
    base_filename = f"{recording_name}.csv"
    logger.info(f"Base filename: {base_filename}")

    # Output directory
    output_directory = f"recordings"
    os.makedirs(output_directory, exist_ok=True)
    logger.info(f"Output directory: {output_directory}")

    csv_filename = base_filename

    # ---------------------------------------------------------------

    # Get the name of the first available input port
    input_port_name = mido.get_input_names()[0]
    logger.info(f"Using input port: {input_port_name}")

    # ---------------------------------------------------------------
    
    # Load .wav file based on the metronome type and tempo
    wav_file_path = f"metronome_tracks/{tempo}_metronome.wav"
    print(f"Metronome track path: {wav_file_path}")

    if not os.path.exists(wav_file_path):
        raise FileNotFoundError(f"The .wav file {wav_file_path} does not exist.")
    wave_obj = sa.WaveObject.from_wave_file(wav_file_path)
    logger.info(f"Loaded .wav file: {wav_file_path}")

    # Get the duration of the .wav file
    with wave.open(wav_file_path, "rb") as wave_file:
        duration = wave_file.getnframes() / wave_file.getframerate()
    logger.info(f"Duration of .wav file: {duration} seconds")

    # Prepare a list to store the recorded data
    recorded_data = []
    logger.info("Prepared list to store recorded data.")

    # Open the input port
    with mido.open_input(input_port_name) as inport:
        logger.info(f"Recording on {input_port_name}. Press space to stop.")
        print(f"Recording on {input_port_name}. Press space to stop.")

        # Play .wav file
        play_obj = wave_obj.play()
        logger.info("Started playing metronome track.")

        # Get the current time at the start of the recording
        start_time = time.time()

        # Loop until the space bar is pressed or the duration has passed
        while time.time() - start_time < duration:
            # If space bar is pressed, break the loop
            if keyboard.is_pressed('space'):
                logger.info("Space bar pressed. Stopping recording.")
                print("Stopping recording.")
                break

            # Poll for a MIDI message
            msg = inport.poll()

            # If a MIDI message was received
            if msg is not None:
                # Check if the message is a 'note_on' or 'note_off' message
                if msg.type in ['note_on', 'note_off']:
                    # If it's a 'note_on' message with velocity 0, create a new 'note_off' message
                    if msg.type == 'note_on' and msg.velocity == 0:
                        msg = mido.Message('note_off', note=msg.note, velocity=0, time=msg.time, channel=msg.channel)
                    # Calculate the elapsed time since the start of the recording
                    elapsed_time = time.time() - start_time

                    # Store the MIDI message and the elapsed time
                    recorded_message = [1, float(f"{elapsed_time:.3f}"), msg.type, msg.channel, msg.note, msg.velocity]
                    recorded_data.append(recorded_message)
                    logger.debug(f"Recorded MIDI message: {recorded_message}")

                    # Print the MIDI message to the console
                    print(f"Recorded MIDI message: {recorded_message}")

            # Sleep for a short duration to reduce CPU usage
            time.sleep(0.01)
 
        logger.info("Recording stopped.")
        print("Recording stopped.")

    full_csv_path = os.path.join(output_directory, csv_filename)
    logger.info(f"Saving data to: {full_csv_path}")

    # ---------------------------------------------------------------

    # Write the recorded data to a .csv file
    with open(full_csv_path, 'w', newline='') as csvfile:
        logger.info("Open full_csv_path.")
        writer = csv.writer(csvfile)
        logger.info("Write csv.")
        writer.writerow(["track", "time", "type", "channel", "note", "velocity"])
        logger.info("write header.")
        writer.writerows(recorded_data)
        logger.info("write rows.")

    # ---------------------------------------------------------------

    logger.info(f"Data saved to {log_filename}")
    print(f"Data saved to {log_filename}")

except Exception as e:
    logger.error(f"An error occurred: {e}")
    print(f"An error occurred: {e}")
